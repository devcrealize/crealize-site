<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ€§èƒ½æµ‹è¯• - ãƒ¡ã‚«ã‚»ãƒ©æŠ€ç ”</title>
    <link rel="stylesheet" href="styles.min.css">
    <style>
        .performance-dashboard {
            max-width: 800px;
            margin: 2rem auto;
            padding: 2rem;
            background: #f8f9fa;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            margin: 0.5rem 0;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #3f51b5;
        }
        
        .metric.good { border-left-color: #4CAF50; }
        .metric.warning { border-left-color: #FF9800; }
        .metric.poor { border-left-color: #f44336; }
        
        .metric-value {
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .test-button {
            background: #3f51b5;
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 8px;
            cursor: pointer;
            margin: 1rem 0;
            font-size: 1rem;
        }
        
        .test-button:hover {
            background: #303f9f;
        }
    </style>
</head>
<body>
    <div class="performance-dashboard">
        <h1>ğŸš€ æ€§èƒ½æµ‹è¯•ä»ªè¡¨æ¿</h1>
        <p>æ­¤é¡µé¢ç”¨äºæµ‹è¯•ç½‘ç«™æ€§èƒ½ä¼˜åŒ–æ•ˆæœ</p>
        
        <div class="metric">
            <span>First Contentful Paint (FCP)</span>
            <span class="metric-value" id="fcp">æµ‹è¯•ä¸­...</span>
        </div>
        
        <div class="metric">
            <span>Largest Contentful Paint (LCP)</span>
            <span class="metric-value" id="lcp">æµ‹è¯•ä¸­...</span>
        </div>
        
        <div class="metric">
            <span>Total Blocking Time (TBT)</span>
            <span class="metric-value" id="tbt">æµ‹è¯•ä¸­...</span>
        </div>
        
        <div class="metric">
            <span>Cumulative Layout Shift (CLS)</span>
            <span class="metric-value" id="cls">æµ‹è¯•ä¸­...</span>
        </div>
        
        <div class="metric">
            <span>Speed Index</span>
            <span class="metric-value" id="speed-index">æµ‹è¯•ä¸­...</span>
        </div>
        
        <button class="test-button" onclick="runPerformanceTest()">ğŸ”„ é‡æ–°æµ‹è¯•</button>
        <button class="test-button" onclick="window.location.href='index.html'">ğŸ  è¿”å›ä¸»é¡µ</button>
        
        <div id="results" style="margin-top: 2rem; padding: 1rem; background: white; border-radius: 8px; display: none;">
            <h3>æµ‹è¯•ç»“æœåˆ†æ</h3>
            <div id="analysis"></div>
        </div>
    </div>

    <script>
        let fcpTime = 0;
        let lcpTime = 0;
        let tbtTime = 0;
        let clsValue = 0;
        let speedIndex = 0;
        
        // æ€§èƒ½ç›‘æ§
        if ('PerformanceObserver' in window) {
            // FCP
            const fcpObserver = new PerformanceObserver((list) => {
                const entries = list.getEntries();
                const fcp = entries[entries.length - 1];
                fcpTime = fcp.startTime;
                document.getElementById('fcp').textContent = `${fcpTime.toFixed(0)}ms`;
                updateMetricClass('fcp', fcpTime);
            });
            fcpObserver.observe({ entryTypes: ['paint'] });
            
            // LCP
            const lcpObserver = new PerformanceObserver((list) => {
                const entries = list.getEntries();
                const lcp = entries[entries.length - 1];
                lcpTime = lcp.startTime;
                document.getElementById('lcp').textContent = `${lcpTime.toFixed(0)}ms`;
                updateMetricClass('lcp', lcpTime);
            });
            lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
            
            // TBT
            const tbtObserver = new PerformanceObserver((list) => {
                let totalBlockingTime = 0;
                for (const entry of list.getEntries()) {
                    if (entry.duration > 50) {
                        totalBlockingTime += entry.duration - 50;
                    }
                }
                tbtTime = totalBlockingTime;
                document.getElementById('tbt').textContent = `${tbtTime.toFixed(0)}ms`;
                updateMetricClass('tbt', tbtTime);
            });
            tbtObserver.observe({ entryTypes: ['longtask'] });
            
            // CLS
            const clsObserver = new PerformanceObserver((list) => {
                let cls = 0;
                for (const entry of list.getEntries()) {
                    cls += entry.value;
                }
                clsValue = cls;
                document.getElementById('cls').textContent = clsValue.toFixed(3);
                updateMetricClass('cls', clsValue);
            });
            clsObserver.observe({ entryTypes: ['layout-shift'] });
        }
        
        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆ†æ
        window.addEventListener('load', () => {
            setTimeout(() => {
                analyzePerformance();
            }, 1000);
        });
        
        function updateMetricClass(metric, value) {
            const element = document.getElementById(metric);
            const parent = element.parentElement;
            
            parent.classList.remove('good', 'warning', 'poor');
            
            if (metric === 'fcp') {
                if (value < 1800) parent.classList.add('good');
                else if (value < 3000) parent.classList.add('warning');
                else parent.classList.add('poor');
            } else if (metric === 'lcp') {
                if (value < 2500) parent.classList.add('good');
                else if (value < 4000) parent.classList.add('warning');
                else parent.classList.add('poor');
            } else if (metric === 'tbt') {
                if (value < 200) parent.classList.add('good');
                else if (value < 600) parent.classList.add('warning');
                else parent.classList.add('poor');
            } else if (metric === 'cls') {
                if (value < 0.1) parent.classList.add('good');
                else if (value < 0.25) parent.classList.add('warning');
                else parent.classList.add('poor');
            }
        }
        
        function analyzePerformance() {
            const analysis = document.getElementById('analysis');
            const results = document.getElementById('results');
            
            let score = 0;
            let recommendations = [];
            
            // FCPåˆ†æ
            if (fcpTime < 1800) {
                score += 20;
            } else if (fcpTime < 3000) {
                score += 10;
                recommendations.push('FCPæ—¶é—´è¾ƒé•¿ï¼Œå»ºè®®ä¼˜åŒ–é¦–å±æ¸²æŸ“');
            } else {
                recommendations.push('FCPæ—¶é—´è¿‡é•¿ï¼Œéœ€è¦ç«‹å³ä¼˜åŒ–');
            }
            
            // LCPåˆ†æ
            if (lcpTime < 2500) {
                score += 25;
            } else if (lcpTime < 4000) {
                score += 15;
                recommendations.push('LCPæ—¶é—´è¾ƒé•¿ï¼Œå»ºè®®ä¼˜åŒ–æœ€å¤§å†…å®¹æ¸²æŸ“');
            } else {
                recommendations.push('LCPæ—¶é—´è¿‡é•¿ï¼Œéœ€è¦ç«‹å³ä¼˜åŒ–');
            }
            
            // TBTåˆ†æ
            if (tbtTime < 200) {
                score += 25;
            } else if (tbtTime < 600) {
                score += 15;
                recommendations.push('TBTæ—¶é—´è¾ƒé•¿ï¼Œå»ºè®®ä¼˜åŒ–JavaScriptæ‰§è¡Œ');
            } else {
                recommendations.push('TBTæ—¶é—´è¿‡é•¿ï¼Œéœ€è¦ç«‹å³ä¼˜åŒ–');
            }
            
            // CLSåˆ†æ
            if (clsValue < 0.1) {
                score += 30;
            } else if (clsValue < 0.25) {
                score += 20;
                recommendations.push('CLSå€¼è¾ƒé«˜ï¼Œå»ºè®®ä¼˜åŒ–å¸ƒå±€ç¨³å®šæ€§');
            } else {
                recommendations.push('CLSå€¼è¿‡é«˜ï¼Œéœ€è¦ç«‹å³ä¼˜åŒ–');
            }
            
            let performanceLevel = '';
            if (score >= 90) performanceLevel = 'ä¼˜ç§€';
            else if (score >= 70) performanceLevel = 'è‰¯å¥½';
            else if (score >= 50) performanceLevel = 'ä¸€èˆ¬';
            else performanceLevel = 'éœ€è¦ä¼˜åŒ–';
            
            analysis.innerHTML = `
                <h4>æ€§èƒ½å¾—åˆ†: ${score}/100 (${performanceLevel})</h4>
                <h4>ä¼˜åŒ–å»ºè®®:</h4>
                <ul>
                    ${recommendations.map(rec => `<li>${rec}</li>`).join('')}
                </ul>
            `;
            
            results.style.display = 'block';
        }
        
        function runPerformanceTest() {
            location.reload();
        }
    </script>
</body>
</html> 